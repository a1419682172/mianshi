# 环境噪声监测报警系统

## 目录
摘要	2
绪论	3
第一章：硬件设计部分	6
1.1噪声监测系统的硬件选择	6
1.1.1  STC89C52RC单片机	6
1.1.2  ADC0832数模转换芯片	11
1.1.3 蜂鸣报警器	12
1.1.4 声音传感器	13
1.2制版流程	14
1.2.1 制作电路原理图	14
1.2.2  PCB图制作	15
1.2.3 热转印	16
1.2.4 腐蚀	16
1.2.5 打孔	17
1.2.6 去漆	17
1.2.7 测试	18
1.3组装流程	19
1.4焊接流程	19
第二章：软件设计部分	20
2.1噪声监测系统的软件选择	20
2.1.1  Keil编程软件	20
2.2.2  STC-ISP	21
2.2 程序设计流程	21
2.2.1 程序流程图	21
2.2.2 关键部分程序	21
2.3程序下载及调试	21
第三章：总体方案说明	22
3.1 总体任务解析	22
3.2 硬件连接（配实物图）	23
3.3操作过程	24
参考文献	25
附：程序代码	26

摘要
在人们的日常生活中，存在许许多多的噪声。无论是工业噪声，生活噪声还是自然噪声，它们不但影响人们的正常生活作息、学习与工作，而且严重的甚至会危害人体健康安全。因此，噪声的监测与防治成了一项迫在眉睫同时举足轻重的环境保护任务。能够有效的检测噪声，做到防范于未然，能够有效提高人们的生活质量、加强环境保护。
本次报告详细介绍及应用了环境噪声监测报警系统的原理及系统结构。以STC89C52RC单片机为核心，涉及噪声录入、处理、显示、报警等基本过程。外界噪声信号通过传声器输入，将声信号转换为电信号，然后对它放大，再交直流V/F转换，进一步数据采集，最后出入到单片机进行处理，并转换成相应的噪声分贝值通过LCD显示，并设定目标值，超出该值发出报警，从而使系统达到完全，实现噪声的实时监测。

绪论

1.噪声的概念

噪声是一种主观评价标准，即一切影响他人的声音均为噪声，无论是音乐或者机械声等等。  
从环境保护的角度看，凡是影响人们正常学习，工作和休息的声音凡是人们在某些场合“不需要的声音”，都统称为噪声。如机器的轰鸣声，各种交通工具的马达声、鸣笛声，人的嘈杂声及各种突发的声响等，均称为噪声。从物理角度看，噪声是发声体做无规则振动时发出的声音。噪声污染属于感觉公害，它与人们的主观意愿有关，与人们的生活状态有关，因而它具有与其他公害不同的特点。

2.噪声的危害

干扰休息和睡眠、影响工作效率：
①干扰休息和睡眠。休息和睡眠是人们消除疲劳、恢复体力和维持健康的必要条件。但噪声使人不得安宁，难以休息和入睡。当人辗转不能入睡时，便会心态紧张，呼吸急促，脉搏跳动加剧，大脑兴奋不止，第二天就会感到疲倦，或四肢无力。
②使工作效率降低。研究发现，噪声超过85分贝，会使人感到心烦意乱，人们会感觉到吵闹，因而无法专心地工作，结果会导致工作效率降低。
损伤听觉、视觉器官
①损害心血管。噪声是心血管疾病的危险因子，噪声会加速心脏衰老，增加心肌梗塞发病率。
②强的噪声可以引起耳部的不适，如耳鸣、耳痛、听力损伤。
③噪声对视力的损害。人们只知道噪声影响听力，其实噪声还影响视力。

对人体的生理影响
①损害心血管。噪声是心血管疾病的危险因子，噪声会加速心脏衰老，增加心肌梗塞发病率。
②对女性生理机能的损害。女性受噪声的威胁，还可以有月经失调、流产及早产等，如导致女性性机能紊乱，月经失调，流产率增加等。
③噪声还可以引起如神经系统功能紊乱、精神障碍、内分泌紊乱甚至事故率升高。

3.防治噪声污染的一些办法

①控制噪声源。降低声源噪音，工业、交通运输业可以选用低噪音的生产设备和改进生产工艺，或者改变噪音源的运动方式（如用阻尼、隔振等措施降低固体发声体的振动）
②阻断噪声传播。在传音途径上降低噪音，控制噪音的传播，改变声源已经发出的噪音传播途径，如采用吸音、隔音、音屏障、隔振等措施，以及合理规划城市和建筑布局等。
③在人耳处减低噪声。受音者或受音器官的噪音防护，在声源和传播途径上无法采取措施，或采取的声学措施仍不能达到预期效果时，就需要对受音者或受音器官采取防护措施，如长期职业性噪音暴露的工人可以戴耳塞 、耳罩或头盔等护耳器。

4.噪声的利用
①利用噪声除草。
②利用噪声发电。
③利用噪声来制冷。
④利用噪声除尘。
⑤利用噪声克敌。
⑥利用噪声诊病。
⑦利用噪声有源消声

5.应用背景
     无论是利用噪声还是防止噪声，都必须确定其量值。在长期的科学研究和工程实践中已逐步形成了一门较完整的噪声工程学科，可供进行理论计算和分析。但这些还是理论上的假设并没有经过实验的证明，所以需要收集大量的数据来支持这些理论。
随着现代工业和科技的飞速发展，对各种仪器设备提出了低噪声的要求，需要进行噪声的分析与设计，并通过实验来验证，改进设计。我们小组所实现的课题，从实验及硬件方向研究噪声监测及报警，对未来实际应用发展与市场需求具有重大意义。

# 第一章：硬件设计部分

## 1.1噪声监测系统的硬件选择
### 1.1.1  STC89C52RC单片机
#### 概述
STC89C52RC单片机是宏晶科技推出的新一代高速/低功耗/超强抗干扰的单片机，指令代码完全兼容传统8051单片机，12时钟/机器周期和6时钟/机器周期可以任意选择
#### 主要特性
- 增强型8051单片机，6时钟/机器周期和12时钟/机器周期可以任意选择，指令代码完全兼容传统8051.
- 工作电压：5.5V～3.3V（5V单片机）/3.8V～2.0V（3V单片机）
- 工作频率范围：0～40MHz，相当于普通8051的0～80MHz，实际工作频率可达48MHz
 -用户应用程序空间为8K字节
 -片上集成512字节RAM
 -通用I/O口（32个），复位后为：P1/P2/P3/P4是准双向口/弱上拉，P0口是漏极开路输出，作为总线扩展用时，不用加上拉电阻，作为I/O口用时，需加上拉电阻。
- ISP（在系统可编程）/IAP（在应用可编程），无需专用编程器，无需专用仿真器，可通过串口（RxD/P3.0,TxD/P3.1）直接下载用户程序，数秒即可完成一片
- 具有EEPROM功能
- 具有看门狗功能
- 共3个16位定时器/计数器。即定时器T0、T1、T2
- 外部中断4路，下降沿中断或低电平触发电路，Power Down模式可由外部中断低电平触发中断方式唤醒
- 通用异步串行口（UART），还可用定时器软件实现多个UART
- 工作温度范围：-40～+85℃（工业级）/0～75℃（商业级）
- PDIP封装

#### 引脚功能
   STC89C52管脚图如下图所示。

![ STC89C52管脚图](https://upload-images.jianshu.io/upload_images/22450657-ffcdf9e44991d5a9?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

VCC：供电电压。 
GND：接地。 

P0口：P0口为一个8位漏级开路双向I/O口，每脚可吸收8TTL门电流。当P0口的管脚第一次写1时，被定义为高阻输入。P0能够用于外部程序数据存储器，它可以被定义为数据/地址的低八位。在FIASH编程时，P0 口作为原码输入口，当FIASH进行校验时，P0输出原码，此时P0外部必须接上拉电阻。 

P1口：P1口是一个内部提供上拉电阻的8位双向I/O口，P1口缓冲器能接收输出4TTL门电流。P1口管脚写入1后，被内部上拉为高，可用作输入，P1口被外部下拉为低电平时，将输出电流，这是由于内部上拉的缘故。在FLASH编程和校验时，P1口作为低八位地址接收。 

P2口：P2口为一个内部上拉电阻的8位双向I/O口，P2口缓冲器可接收，输出4个TTL门电流，当P2口被写“1”时，其管脚被内部上拉电阻拉高，且作为输入。并因此作为输入时，P2口的管脚被外部拉低，将输出电流。这是由于内部上拉的缘故。P2口当用于外部程序存储器或16位地址外部数据存储器进行存取时，P2口输出地址的高八位。在给出地址“1”时，它利用内部上拉优势，当对外部八位地址数据存储器进行读写时，P2口输出其特殊功能寄存器的内容。P2口在FLASH编程和校验时接收高八位地址信号和控制信号。 

P3口：P3口管脚是8个带内部上拉电阻的双向I/O口，可接收输出4个TTL门电流。当P3口写入“1”后，它们被内部上拉为高电平，并用作输入。作为输入，由于外部下拉为低电平，P3口将输出电流（ILL）这是由于上拉的缘故。 P3口也可作为AT89C51的一些特殊功能口，如下表所示：

P3口管脚 备选功能 
P3.0 RXD（串行输入口） 
P3.1 TXD（串行输出口） 
P3.2 /INT0（外部中断0） 
P3.3 /INT1（外部中断1） 
P3.4 T0（计时器0外部输入） 
P3.5 T1（计时器1外部输入） 
P3.6 /WR（外部数据存储器写选通） 
P3.7 /RD（外部数据存储器读选通） 
P3口同时为闪烁编程和编程校验接收一些控制信号。 

RST：复位输入。当振荡器复位器件时，要保持RST脚两个机器周期的高电平时间。

ALE/PROG：当访问外部存储器时，地址锁存允许的输出电平用于锁存地址的低位字节。在FLASH编程期间，此引脚用于输入编程脉冲。在平时，ALE端以不变的频率周期输出正脉冲信号，此频率为振荡器频率的1/6。因此它可用作对外部输出的脉冲或用于定时目的。然而要注意的是：每当用作外部数据存储器时，将跳过一个ALE脉冲。如想禁止ALE的输出可在SFR8EH地址上置0。此时， ALE只有在执行MOVX，

MOVC指令是ALE才起作用。另外，该引脚被略微拉高。如果微处理器在外部执行状态ALE禁止，置位无效。 

/PSEN：外部程序存储器的选通信号。在由外部程序存储器取指期间，每个机器周期两次/PSEN有效。但在访问外部数据存储器时，这两次有效的/PSEN信号将不出现。 

/EA/VPP：当/EA保持低电平时，则在此期间外部程序存储器（0000H-FFFFH），不管是否有内部程序存储器。注意加密方式1时，/EA将内部锁定为RESET；当/EA端保持高电平时，此间内部程序存储器。在FLASH编程期间，此引脚也用于施加12V编程电源（VPP）。 

TAL1：反向振荡放大器的输入及内部时钟工作电路的输入。 
XTAL2：来自反向振荡器的输出。 


#### 复位
单片机复位电路就好比电脑的重启部分，当电脑在使用中出现死机，按下重启按钮电脑内部的程序从头开始执行。单片机也一样，当单片机系统在运行中，受到环境干扰出现程序跑飞的时候，按下复位按钮内部的程序自动从头开始执行。单片机复位电路就好比电脑的重启部分，当电脑在使用中出现死机，按下重启按钮电脑内部的程序从头开始执行。单片机也一样，当单片机系统在运行中，受到环境干扰出现程序跑飞的时候，按下复位按钮内部的程序自动从头开始执行。

![复位电路原理图](https://upload-images.jianshu.io/upload_images/22450657-48793e8bc3732580?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

#### 晶振
结合单片机内部的电路，产生单片机所必须的时钟频率，单片机的所有指令的执行都是建立在晶振产生的频率上，晶振的产生的频率越高，单片机的运行速度就越快。
随着晶体的电能和机械能之间的相互转化，在共振条件下工作的结晶，提供稳定，精确的单频振荡。
![晶振](https://upload-images.jianshu.io/upload_images/22450657-8713fb88fb3b243b?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

### 1.1.2  ADC0832数模转换芯片
#### 概述
ADC0832 为8位分辨率A/D转换芯片，其最高分辨可达256级，可以适应一般的模拟量转换要求。其内部电源输入与参考电压的复用，使得芯片的模拟电压输入在0~5V之间。芯片转换时间仅为32μS，据有双数据输出可作为数据校验，以减少数据误差，转换速度快且稳定性能强。独立的芯片使能输入，使多器件挂接和处理器控制变的更加方便。通过DI 数据输入端，可以轻易的实现通道功能的选择。
####特点
· 输入输出电平与TTL/CMOS相兼容;
· 5V电源供电时输入电压在0~5V之间;
· 工作频率为250KHZ，转换时间为32μS;
· 一般功耗仅为15mW;
· 8P、14P-DIP(双列直插)、PICC 多种封装;
· 商用级芯片温宽为0°C to +70°C，工业级芯片温宽为−40°C to +85°C;
#### 芯片接口说明:
· CS_片选使能，低电平芯片使能。
· CH0 模拟输入通道0，或作为IN+/-使用。
· CH1 模拟输入通道1，或作为IN+/-使用。
· GND 芯片参考0 电位(地)。
· DI 数据信号输入，选择通道控制。
· DO 数据信号输出，转换数据输出。
· CLK 芯片时钟输入。
· Vcc/REF 电源输入及参考电压输入(复用)。
#### 管脚图
![管脚图](https://upload-images.jianshu.io/upload_images/22450657-923d25186d5ff52d?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

### 1.1.3 蜂鸣报警器
#### 概述
蜂鸣器是一种一体化结构的电子讯响器，他广泛应用于计机、打印机、复印机、报警器、电话机等电子产品中作发声器件。 蜂鸣器按工作原理可以分为压电式和电磁式两种类型。电磁式蜂鸣器由振荡器、电磁线圈、磁铁、振动膜片及外壳等组成。接通电源后，振荡器产生的音频信号电流通过电磁线圈，使电磁线圈产生磁场，振动膜片在电磁线圈和磁铁的相互作用下，周期性地振动发声。 压电式蜂鸣器主要由阻抗匹配器及共鸣箱、多谐振荡器、压电蜂鸣片、外壳等组成。多谐振荡器是由晶体管或着集成电路所构成，当接通1.5~15V直流电源后多谐振荡器起振输出1.5～2.5kHZ的音频信号，蜂鸣器发出声音。
#### 原理图
![原理图](https://upload-images.jianshu.io/upload_images/22450657-778ca1f9d1c787d8?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

### 1.1.4 声音传感器
#### 概述
声音传感器的作用相当于一个话筒（麦克风）。它用来接收声波，显示声音的振动图像，但不能对噪声的强度进行测量。
该传感器内置一个对声音敏感的电容式驻极体话筒。声波使话筒内的驻极体薄膜振动，导致电容的变化，而产生与之对应变化的微小电压。这一电压随后被转化成0-5V的电压，经过A/D转换被数据采集器接受，并传送给计算机。
#### 功能原理
![功能原理图](https://upload-images.jianshu.io/upload_images/22450657-1563c9b97717cd31?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

 模块有2个输出： 1、AO，模拟量输出，实时输出麦克风的电压信号 2、DO，当声音强度到达某个阀值时，输出高低电平信号，【阀值-灵敏度可以通过电位器调节】    模块特点： 1、尺寸小，36mm X 16mm 2、有3mm的安装螺丝孔 3、可以使用3-5.5v直流电源供电 4、有模拟量输出 5、有阀值翻转电平输出 6、极柱体麦克风，灵敏度高。 7、有电源指示灯 8、比较器输出有指示灯 
#### 实物图片
![实物图片](https://upload-images.jianshu.io/upload_images/22450657-1cbcb20680f874b3?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

## 1.2制版流程
### 1.2.1 制作电路原理图
用AD软件绘制电路原理图。（及所需元件封装库文件），成果如下图。
![电路原理图](https://upload-images.jianshu.io/upload_images/22450657-4954131e943b4ec9?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

### 1.2.2  PCB图制作
由原理图生成PCB图，并合理化布线，如下图所示：
![PCB图](https://upload-images.jianshu.io/upload_images/22450657-c61ef815e1767d67?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

### 1.2.3 热转印
PCB图设计分层完成后，在电脑上下载打印驱动程序用USB接口连接打印机，将黄油纸放到打印机入口，然后开始打印。PCB电路连接线路自动打印到黄油纸上。注意保证大小适合覆铜板9*15的大小范围，并且线路无断口，油墨清晰。
然后用热转印法将黄油纸上的电路线路图印到覆铜板上。首先将黄油纸线路与覆铜板完全符合相贴，将黄油纸多余的部分沿着覆铜板四边对折，尽量完全贴合，成较为标准的长方形。包裹完毕后，用热熨斗插上电源开到接近最大功率，然后开始对黄油纸反复熨烫。熨烫过程中，前后反复移动熨斗，并注意施力往下压，时间持续5---7分钟，保证黄油纸不被熨斗烫破。拆开黄油纸后，覆铜板上应该清晰的看到线路连接完整，无掉漆掉色，油墨清晰厚实。若有部分微小油墨不清晰或线路断开处，用马克笔在断处画上笔迹连接。

![热转印图](https://upload-images.jianshu.io/upload_images/22450657-ac7d227ec0415cc2?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

### 1.2.4 腐蚀
用PCB铜板腐蚀剂与水按1:4的比例混合，并且加入一定热水或者打开日光灯提高环境温度使水温达到50摄氏度左右。用镊子夹住覆铜板缓缓放入溶液中，要保证板子完全侵入。大约浸泡腐蚀时间15——20分钟左右。在腐蚀过程中，要不停的摇晃装溶液的塑料盆，让溶液不停的洗刷覆铜板表面，可以加快腐蚀速度，保证腐蚀将板上的其他铜料彻底清除。事后用清水稍稍冲洗板子，用干净的卫生纸擦拭完水渍，干燥光洁。
![腐蚀](https://upload-images.jianshu.io/upload_images/22450657-09c4022b99cf84e5?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

### 1.2.5 打孔
使用专业的机器，选择大小合适的针头，针头安装完毕后。开启电源，查看是否能正常工作，并调整高度。打孔过程时，先关闭电源，调整高度，看钻针是否刚好对准转孔，核实无误后。抬高钻针高度，打开电源，然后在一鼓作拨下握柄，直接钻开板子。然后如法炮制，依次钻开覆铜板上所有孔。注意如有大孔，在大孔处多钻几个小孔，合成一个大孔。保证器件的管脚可以顺利穿过。
![打孔](https://upload-images.jianshu.io/upload_images/22450657-6c24d6d6dc6d90af?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

### 1.2.6 去漆
用卫生纸蘸上酒精，擦拭干净铜板表面。然后用砂纸开始磨砂板上线路图的黑漆。磨砂过程既要用力擦掉黑漆又要注意不能过分磨砂露出的黄铜部分。在擦掉所有黑漆后，确认线路图现在全是露出的黄铜部分，无断开或短路部分。最后再用卫生纸蘸上酒精擦轻轻拭板子，去掉碎渣。确保板子表面干燥光洁。
![去漆](https://upload-images.jianshu.io/upload_images/22450657-fa4d34e42b8094bc?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

### 1.2.7 测试
以上流程完成后，用万用表测试板子上的铜线是否有断开或短路的地方。具体操作为打开万用表后，正确插上红黑表笔，将红笔笔头放在线路的一端孔处，将黑笔笔头放在线路另一头，若万用表发出滴的一声，则表示该线路没有问题。
我们将所有线路的测试了一遍，未发现问题，确认板子制作无误。到此为止，便是制版的全部流程，没有发现问题。
![测试](https://upload-images.jianshu.io/upload_images/22450657-2ff757d0bbaf0f25?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

## 1.3组装流程
我们所有的元器件都到了以后。根据设计的电路原理图和PCB图开始组装元器件。首先确认所有元器件型号都符合我们的要求。然后在看是否所有器件的管脚能否穿过孔。以上都确认无误后，开始组装，实物图如下。
![组装](https://upload-images.jianshu.io/upload_images/22450657-eea7019a1342b2d5?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

## 1.4焊接流程
  准备好焊锡枪和焊条，将温度调到600摄氏度偏上的地方，然后开始焊接。焊接过程中注意焊料不能粘到旁边的铜板线路造成短路。等全部焊接完毕后，便可以开始软件下载调试，实物图如下.

![焊接](https://upload-images.jianshu.io/upload_images/22450657-65c4c39031d3d974?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

# 第二章：软件设计部分
## 2.1噪声监测系统的软件选择
### 2.1.1  Keil编程软件
#### 概述

Keil C51软件提供丰富的库函数和功能强大的集成开发调试工具，全Windows界面。另外重要的一点，只要看一下编译后生成的汇编代码，就能体会到Keil 的优势。 
C51工具包的整体结构，uVision与Ishell分别是C51 for Windows和for Dos的集成开发环境(IDE），可以完成编辑、编译、连接、调试、仿真等整个开发流程。开发人员可用IDE本身或其它编辑器编辑C或汇编源文件。然后分别由C51及C51编译器编译生成目标文件（.OBJ）。目标文件可由LIB51创建生成库文件，也可以与库文件一起经L51连接定位生成绝对目标文件(.ABS）。ABS文件由OH51转换成标准的Hex文件，以供调试器dScope51或tScope51使用进行源代码级调试，也可由仿真器使用直接对目标板进行调试，也可以直接写入程序存贮器如EPROM中。 仿真器标配11.0592MHz的晶振，但用户可以在仿真器上的晶振插孔中换插其他频率的晶振。 仿真器上的复位按钮只复位仿真芯片，不复位目标系统。 

仿真芯片的31脚（/EA）已接至高电平，所以仿真时只能使用片内ROM，不能使用片外ROM；但仿真器外引插针中的31脚并不与仿真芯片的31脚相连，故该仿真器仍可插入到扩展有外部ROM（其CPU的/EA引脚接至低电平）的目标系统中使用。
 
Keil C51生成的目标代码效率非常之高，多数语句生成的汇编代码很紧凑，容易理解。在开发大型软件时更能体现高级语言的优势。与汇编相比，C语言在功能上、结构性、可读性、可维护性上有明显的优势，因而易学易用。用过汇编语言后再使用C来开发，体会更加深刻。

### 2.2.2  STC-ISP 
   STC-ISP 是一款单片机下载编程烧录软件，是针对STC系列单片机而设计的，可下载STC89系列、12C2052系列和12C5410等系列的STC单片机，使用简便，现已被广泛使用。

## 2.2 程序设计流程
### 2.2.1 程序流程图
![程序流程图](https://upload-images.jianshu.io/upload_images/22450657-569c16c7b4c94629?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

### 2.2.2 关键部分程序
AD芯片：将模拟信号转换为数字信号，输入至单片机
sbit ADC0832_CS=P2^0;
sbit ADC0832_CLK=P2^1;
sbit ADC0832_DIO=P2^2;
 
unsigned int  A_D(unsigned char DI)
{
   unsigned char i,dat;
   ADC0832_CS=1;   //一个转换周期开始
   ADC0832_CLK=0;  //为第一个脉冲作准备
   ADC0832_CS=0;  //CS置0，片选有效

   ADC0832_DIO=1;    //DIO置1，规定的起始信号  
   ADC0832_CLK=1;   //第一个脉冲
   ADC0832_CLK=0;   //第一个脉冲的下降沿，此前DIO必须是高电平
   ADC0832_DIO=1;   //DIO置1， 通道选择信号  
   ADC0832_CLK=1;   //第二个脉冲，第2、3个脉冲下沉之前，DI必须跟别输入两位数据用于选择通道，这里选通道CH0 
   ADC0832_CLK=0;   //第二个脉冲下降沿 
   ADC0832_DIO=DI;   //DI置0，选择通道0
   ADC0832_CLK=1;    //第三个脉冲
   ADC0832_CLK=0;    //第三个脉冲下降沿 
   ADC0832_DIO=1;    //第三个脉冲下沉之后，输入端DIO失去作用，应置1
   ADC0832_CLK=1;    //第四个脉冲
   for(i=0;i<8;i++)  //高位在前
    {
      ADC0832_CLK=1;         //第四个脉冲
      ADC0832_CLK=0; 
      dat<<=1;       //将下面储存的低位数据向右移
  dat|=(unsigned char)ADC0832_DIO;   //将输出数据DIO通过或运算储存在dat最低位 
    }             
    ADC0832_CS=1;          //片选无效 
 return dat;  //将读书的数据返回  

## 2.3程序下载及调试
   在KEIL软件上用C语言编写程序代码（全部代码见附件），然后用STC_ISP程序烧写软件将代码烧录下载到单片机上，查看实验现象是否符合要求并进行调试。 

![程序调试](https://upload-images.jianshu.io/upload_images/22450657-31b5b3715973c73c?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

# 第三章：总体方案说明
## 3.1 总体任务解析
   本次课题设计的主要任务是完成基于52单片机的环境噪声监测报警系统设计，它的主要设计是以单片机为核心，采用V/F数模转换技术的便携式环境噪声测量报警仪，要求能够实现环境中噪声的实时监测并准确无误的显示在LED1602液晶显示屏上，给出噪声的大致水平显示，当噪声水平超出限定值由蜂鸣报警器发出报警声。
  本次课题任务设计方案由硬件设计和软件设计两部分组成。噪声测量报警仪的硬件设计部分包括噪声信号由声信号到电信号的转换、放大、AD数模转换电路以及单片机的系统硬件电路、LED显示电路、蜂鸣报警电路。软件部分包括使用C语言编程，能够实现对信号的采集、转换及显示、报警。在遵循软硬件相结合的原则下，先进行硬件电路的设计，再进行软件编程，进行模块化设计，并对各模块进行调试，最后进行软硬件联合调试和故障的排除，最终得到符合要求能够正常工作的噪声测量报警仪。

## 3.2 硬件连接（配实物图）
根据所设计的电路原理图图PCB图进行硬件连接。
用3P排针一段插入孔进行焊接，然后另一端连接母对母杜邦线，杜邦线另一端在连接声音传感器的针头。
将16P排针插入16P排座，排针的一端焊接1602液晶显示屏，将其固定好。而排座的另一端16的针头插入板上的孔洞，进行焊接。
STC89C52单片机芯片将引脚插入20P双排插座，然后将双排插座的引脚插入板上的孔中，进行焊接。
其余所用到的自锁开关、按键模块、三极管、LCD二极管、ADC0832数模转换芯片、1K 10K电阻，电阻电容、瓷片第电容、蜂鸣报警器、下载线接线4P排针，特殊3管脚可调电阻直接将其管脚插入覆铜板上所对应的孔中，进行焊接。
注意事项，在焊接过程中，在孔处的焊锡不可以连接到其他铜线上，避免造成短路断路。
### 实物图如下
![实物正面](https://upload-images.jianshu.io/upload_images/22450657-253be413aa7e8d49?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
![实物反面](https://upload-images.jianshu.io/upload_images/22450657-46367fe8ec643356?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

##3.3操作过程
   如实物图所示，左上角开关分别为增加和减少阈值键，用来设定报警阈值，lcd下方为复位键，用来复位系统，坐下角为总体开关。接通电源，开启开关后，如图所示，lcd液晶屏上方显示的是实时环境噪声分贝值，下方显示的是报警分贝阈值，当实时环境噪声分贝值超过阈值时，即会触发声光报警。

![现象展示](https://upload-images.jianshu.io/upload_images/22450657-f971424d485a435a?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

# 总结

    短短3个星期的生产实习即将结束，非常感谢学校给了我们这次良好的学习知识和锻炼动手能力的机会，为我们即将步入社会打下了良好的理论实践基础。经过这次生产实习，我们加深了对原来在书本上学习的知识理解，对数电、模电、嵌入式技术、测控技术等相关知识有了进一步的理解和应用。我们小组充分投入其中，不仅锻炼了分工合作的能力，而且互帮互助，共同发现问题、理解问题、解决问题。通过查询大量的文献资料和网络资源，锻炼了我们的信息筛选查找和筛选能力，熟悉了资料的查询，学习和掌握了更多的知识。通过从硬件到软件全面学习操作，是我们完善了知识结构，拓宽了眼界，提高了综合应用能力。同时培养了我们的基本素质，锻炼了耐心，合作，坚持，不怕困难，细心，谨慎，认真的品性。此次生产实习为我们将来的毕业实习提供极大的参考价值和帮助，同时还要感谢各位指导教师对我们极大的帮助和耐心的指导，为此献上由衷的感谢和崇高的敬意。

# 参考文献
1. 杨振江.A/D、D/A转换器接口技术及实用线路[M].西安:西安电子科技大学出版社,1996
2. 周杏鹏等.检测技术及系统设计[M].南京:东南大学出版社,1996
3. 张毅刚等.单片机原理及应用[M].哈尔滨:哈尔滨工业大学出版社,2004
4. 蔡美琴等.MCS—51系列单片机系列及其应用[M].北京:高等教育出版社,1992
5. 张毅刚,刘杰.MCS-51单片机原理及应用[M].哈尔滨:哈尔滨工业大学出版社
6. 大量网络相关资料。

# 附：程序代码

##主程序：
#include <reg52.H>
#include "ADC0832.h"   
#include "LCD1602.h"  
#include "eeprom52.h"  
   

uint Noise_h=0;


uint AD_dat=0;
uint mmm=0;

uint Noise=0;
/*
bit read_dht11=1;	  
uchar U8T_data_H=0;
uchar U8RH_data_H=0;   
bit tmp=1;			   
unsigned char DHT[5];   
  */
uchar ms=0;

 
sbit beep=P2^5;
sbit led0=P2^4;//绿色的灯
sbit led1=P2^3;//红色的灯


sbit key1=P3^5;
sbit key2=P3^6;

bit key1_flag=0;
bit key2_flag=0;

uchar sec=0;
uchar sec1=0;


bit beep1=0;

bit memory_flag=0;

void memroy()
 {
    if(memory_flag) 
	 {	memory_flag=0;
	  	SectorErase(0x2000);
		byte_write(0x2000,Noise_h/256);
		byte_write(0x2001,Noise_h%256);
	 }
 }


void read_memory()
 {
   	Noise_h=byte_read(0x2000)*256+byte_read(0x2001);
	if(Noise_h>999) 
	 {
	   Noise_h=70;
	 }
 }


void key_dispose()
 {
   if(!key1) 
    {
	   if(key1_flag) 
	    {
		  key1_flag=0;
		  if(Noise_h<999) Noise_h++;
		}
		if(sec==0) 
		 {
		   if(Noise_h<999) Noise_h++;
		 }
	}
	else 
	 {
	   if(key1_flag==0) 
	    {
		  key1_flag=1;
		  memory_flag=1;
		}	
		sec=2;
	 }


   if(!key2) 
    {
	   if(key2_flag) 
	    {
		  key2_flag=0;
		  if(Noise_h>0) Noise_h--;
		}
		if(sec1==0) 
		 {
		   if(Noise_h>0) Noise_h--;
		 }
	}
	else 
	 {
	   if(key2_flag==0) 
	    {
		  key2_flag=1;
		  memory_flag=1;
		}
		sec1=2;
	 }






 }


void display()
 {
       LCD1602_write(0,0x80);
	   LCD1602_writebyte("Fenbei:");
	   LCD1602_write(1,0x30+Noise/10000%10);
	   LCD1602_write(1,0x30+Noise/1000%10); 
	   LCD1602_write(1,0x30+Noise/100%10);
	   LCD1602_writebyte(".");
	   LCD1602_write(1,0x30+Noise/10%10);
	   LCD1602_write(1,0x30+Noise%10);
	   LCD1602_writebyte("dB        ");
	

       LCD1602_write(0,0xC0);
	   LCD1602_writebyte("Fazhi:");
	   LCD1602_write(1,0x30+Noise_h/100%10);
	   LCD1602_write(1,0x30+Noise_h/10%10);
	   LCD1602_write(1,0x30+Noise_h%10);
	   LCD1602_writebyte("dB        ");
	}
void main()
 {    

  uchar i;
  TMOD=0x01;
  TH0=0x3c;
  TL0=0xb0;
  ET0=1;
  TR0=1;
  EA=1;
  LCD1602_cls();
  read_memory();
   while(1) 
    {
	  memroy();
	  display();
	  if(i<80)	//转换10次计算平均值
		{  i++;
		   mmm=mmm+A_D(0)/0.51;         

		}
		else 
		 {
		   mmm=mmm/80;							 
		   AD_dat=mmm;
		   mmm=0;
		   i=0;
		   Noise=(AD_dat*36);
		   if(Noise<3000) Noise=Noise*2+3000;	 		
		 }

		   if(Noise>Noise_h*100)
		    {
			  beep1=1;
			  led0=0;
			  led1=1;

			}
		   else 
		    {
			  beep1=0;
			  led1=0;
			  led0=1;
			}

	}


 }
void time0() interrupt 1
 {
    TH0=0x3c;//配置定时时间。50ms
	TL0=0xb0;
	ms++;
	key_dispose();
	if(beep1) beep=~beep;
	else beep=1;
	if(ms>=20) 
	 {
	   ms=0;
	   if(sec!=0) sec--;
	   if(sec1!=0) sec1--;

	 }
 }		


子程序：
ADC0832:
sbit ADC0832_CS=P2^0;
sbit ADC0832_CLK=P2^1;
sbit ADC0832_DIO=P2^2;
 
unsigned int  A_D(unsigned char DI)
{
   unsigned char i,dat;
   ADC0832_CS=1;   //一个转换周期开始
   ADC0832_CLK=0;  
   ADC0832_CS=0;   

   ADC0832_DIO=1;    
   ADC0832_CLK=1;   
   ADC0832_CLK=0;   
   ADC0832_DIO=1;   
   ADC0832_CLK=1;   
   ADC0832_CLK=0;   
   ADC0832_DIO=DI;   
   ADC0832_CLK=1;    
   ADC0832_CLK=0;    
   ADC0832_DIO=1;   
   ADC0832_CLK=1;    
   for(i=0;i<8;i++)  
    {
      ADC0832_CLK=1;         
      ADC0832_CLK=0; 
      dat<<=1;       
  dat|=(unsigned char)ADC0832_DIO;   
    }             
    ADC0832_CS=1;          
 return dat;  

LCD:
#ifndef _LCD1602_H_
#define _LCD1602_H_

#define uchar unsigned char 
#define uint unsigned int

#define LCD1602_dat P0 


sbit LCD1602_rs=P1^0;
sbit LCD1602_rw=P1^1;
sbit LCD1602_e=P1^2;


void LCD1602_delay(uint T)       //延时函数
{
 while(T--);
}

void LCD1602_write(uchar order,dat)      //1602 一个字节  处理
{
    LCD1602_e=0;
    LCD1602_rs=order;
    LCD1602_dat=dat;
    LCD1602_rw=0;
    LCD1602_e=1;
    LCD1602_delay(1);
    LCD1602_e=0;                             
}
void LCD1602_writebyte(uchar *prointer)       //1602 字符串    处理
{
    while(*prointer!='\0')
    {
        LCD1602_write(1,*prointer);
        prointer++;
    }
}
void LCD1602_cls()          //1602 初始化
{
 LCD1602_write(0,0x01);     //1602 清屏 指令
 LCD1602_delay(1500);
 LCD1602_write(0,0x38);     
 LCD1602_delay(1500);
 LCD1602_write(0,0x0c);     
 LCD1602_write(0,0x06);
 LCD1602_write(0,0xd0);
 LCD1602_delay(1500);
}


#endif

ISP：
#define _EEPROM52_H_
#include <intrins.h>



#define RdCommand 0x01 
#define PrgCommand 0x02
#define EraseCommand 0x03 
#define Error 1
#define Ok 0
#define WaitTime 0x01 
sfr ISP_DATA=0xe2; 
sfr ISP_ADDRH=0xe3;
sfr ISP_ADDRL=0xe4;
sfr ISP_CMD=0xe5;
sfr ISP_TRIG=0xe6;
sfr ISP_CONTR=0xe7;
void ISP_IAP_enable(void)
{
  EA = 0;        ISP_CONTR = ISP_CONTR & 0x18;       /* 0001,1000 */
  ISP_CONTR = ISP_CONTR | WaitTime; 
  ISP_CONTR = ISP_CONTR | 0x80;       }
void ISP_IAP_disable(void)
{
  ISP_CONTR = ISP_CONTR & 0x7f; /* ISPEN = 0 */
  ISP_TRIG = 0x00;
  EA   =   1;   
}

void ISPgoon(void)
{
  ISP_IAP_enable();  
  ISP_TRIG = 0x46;  
  ISP_TRIG = 0xb9;    _nop_();
}

unsigned char byte_read(unsigned int byte_addr)
{
 EA = 0;
  ISP_ADDRH = (unsigned char)(byte_addr >> 8);
  ISP_ADDRL = (unsigned char)(byte_addr & 0x00ff);
  ISP_CMD   = ISP_CMD & 0xf8;   
  ISP_CMD   = ISP_CMD | RdCommand;
  ISPgoon();      
  ISP_IAP_disable();    
  EA  = 1;
  return (ISP_DATA);    }
void SectorErase(unsigned int sector_addr)
{
  unsigned int iSectorAddr;
  iSectorAddr = (sector_addr & 0xfe00);
  ISP_ADDRH = (uns

